[push]
	default = current
	recurseSubmodules = on-demand
[color]
	ui = auto
[alias]
	d     = "!f(){ cd ${GIT_PREFIX:-.} ; if [ $# -eq 0 ];then git diff HEAD --color ; else git diff --color \"$@\" ; fi | less -FXR ; }; f"
	ds    = "submodule foreach --recursive \"git d\""
	cm    = "!f(){ cd ${GIT_PREFIX:-.} ; if [ $# -eq 0 ];then git commit ; else git commit -m \"$@\"; fi }; f"
	b     = "branch"
	mn    = "merge --no-edit"
	#bc    = "!git branch | grep \* | cut -d ' ' -f2"
	bc    = "rev-parse --abbrev-ref HEAD"
	a     = "!f(){ cd ${GIT_PREFIX:-.} ; if [ $# -eq 0 ];then git add --all -v; else git add -v \"$@\"; fi }; f"
	ad    = "!f(){ cd ${GIT_PREFIX:-.} git a \"$@\" && git d;}; f"
	amdi  = "!f(){ cd ${GIT_PREFIX:-.} ; if [ $# -eq 0 ];then git commit -S --amend --reuse-message=HEAD; else git commit -S --amend -m \"$@\"; fi }; f"
	aa    = "!f(){ cd ${GIT_PREFIX:-.} ; git a \"$@\"; git amdi ; }; f"
	amd   = "!f(){ cd ${GIT_PREFIX:-.} ; if [ $# -lt 2 ];then git amdi \"$@\" ; else git a \"${@:1:$(($#-1))}\"; git amdi \"${@:$#}\" ; fi }; f"
	ac    = "!f(){ cd ${GIT_PREFIX:-.} ; git a \"${@:1:$(($#-1))}\"; git cm \"${@:$#}\" ; }; f"
	r     = "!f(){ cd ${GIT_PREFIX:-.} ; if [ $# -eq 0 ];then git reset HEAD --hard; else git reset \"$@\"; fi }; f"
	r1    = "reset HEAD^"
	rh    = "!git r && git clean -d -f"
	s     = "!git reset -q && git a && git stash"
	pop   = "stash pop"
	p     = "!f(){ cd ${GIT_PREFIX:-.} ; if [ $# -eq 0 ];then git push -u origin $(git bc); else git push \"$@\"; fi }; f"
	pa    = "push --all"
	f     = "!f(){ cd ${GIT_PREFIX:-.} ; git fetch --all ; git pull --ff-only \"$@\" || git pull \"$@\" ; }; f"
	# TODO: look up the dangers of pull over fetch and make sure they are prevented
	# TODO: 
	fs    = "!f(){ cd ${GIT_PREFIX:-.} ; git f ; git submodule sync ; git submodule update --init --recursive ; }; f"
	chk   = "!f(){ cd ${GIT_PREFIX:-.} ; git checkout -b \"$@\" || git checkout \"$@\" ; git f ; }; f"
	#hist  = "!git log --pretty=format:\"%h %ad | %s%d [%an]\" --graph --date=short --color|less -FXRS"
	l     = "!git log --graph --all                 --oneline --decorate --full-history --date-order --color|less -FXR"
	ll    = "!git log --graph --all -5  --numstat   --oneline --decorate --full-history --date-order --color --show-signature|less -FXR"
	lll   = "!git log --graph --all     --numstat   --oneline --decorate --full-history --date-order --color --show-signature|less -FXR"
	lt    = "!git log --graph --all -20             --oneline --decorate --full-history --date-order --color|less -FXR"
	ltt   = "!git log --graph --all -40             --oneline --decorate --full-history --date-order --color|less -FXR"
	lvl   = "!git log --graph --all -100            --oneline --decorate --full-history --date-order --color|less -FXR"
	lr    = "!git log --graph --all -40 --since=1.weeks --oneline --decorate --full-history --date-order --color|less -FXR"
	pov   = "!git log --graph --all --oneline --decorate --full-history --date-order --color $(git reflog show --format="%h" stash)|awk '/[0-9a-f]{7}....(.....[(]|WIP)/ || !/[0-9a-f]{7}/; END{print}'|less -FXR"
	povm  = "!git log --graph --all --oneline --decorate --full-history --date-order --color $(git reflog show --format="%h" stash)|awk '/[0-9a-f]{7}....(M|.....[(]|WIP)/ || !/[0-9a-f]{7}/; END{print}'|less -FXR"
	lsd   = "!git lt && echo && git status && echo && git d"
	lts   = "!git lt && echo && git status"
	ls    = "!f(){ cd ${GIT_PREFIX:-.} ; if [ $# -eq 0 ];then git ls-tree -r HEAD; else git ls-tree \"$@\"; fi }; f"
	lines = "!git ls|cut -f 2 -|sed 's/[] ()'\\''\\\\[&;]/\\\\&/g'|sed 's/.*/cat &|wc -l;echo \"+0\"/'|sh|xargs|sed 's/ //g'|bc"
	stat  = "status"

	svn-pull  = "svn rebase"
	svn-push  = "svn dcommit"
	svn-clone = "svn clone"

  c-rand = "!git cm \"$(echo 'wtc: ' $(curl http://whatthecommit.com/index.txt))\""
[apply]
	whitespace = fix
[merge]
	ff = false
[status]
	submodulesummary = true
[rerere]
	enabled = true
	autoupdate = true
