-*- mode: org; eval: (org-show-todo-tree '()) -*-
unDeadHerbs's emacs init file

* TODO README
  This config file is loaded by =org-dotemacs=.
* Personage Attributes
  :PROPERTIES:
  :NAME:     Name_and_Rank
  :END:
  #+BEGIN_SRC emacs-lisp
    (setq user-full-name "Murray Fordyce")
    (setq user-mail-address "unDeadHerbs@gmail.com")
    (setq copyright-names-regexp
	  (format "%s <%s>" user-full-name user-mail-address))
  #+END_SRC
* Buffer-wide TODO states
  You need a line like the following one somewhere in the file to be able to mark blocks as broken or unused.
  #+TODO: BROKEN UNUSED CHECK TODO DISABLED | WORKING
** TODO Does the WORKING tag still disable the code?
   If so move DISABLED to there and remove WORKING
* GTD
  Getting Things Done is an old book with lots of opinions, some of
  which are good ideas.

  |------------------+-----------+------------|
  | Action           | Keybind   | Location   |
  |------------------+-----------+------------|
  | Agenda           | C-c a g   | Global     |
  | Capture          | C-c c     | Global     |
  | Effort           | C-c C-x e | Org Header |
  | Refile           | C-c C-w   | Org Header |
  | Task List        | C-c a t   | Global     |
  | Timestamp        | C-c .     | Org        |
  | T-stamp Deadline | C-c d     | Org        |
  | T-stamp Inactive | C-c !     | Org        |
  | T-stamp Schedule | C-c s     | Org        |
  |------------------+-----------+------------|
** TODO Relevant Files
   I've made a ~~/.agenda_files~, either move it's content here or
   move the file into version control.  I made the file because I
   couldn't get lists to work in the below code.
   #+BEGIN_SRC emacs-lisp
     ;;(setq org-directory "~/")
     ;;(setq org-directory "~/org")
     ;;(setq org-agenda-files (list "todo.org" "inbox.org"))
     ;;the files seem to default to ~/org/* and customizing it breaks something
   #+END_SRC
** Capture to Inbox
   :PROPERTIES:
   :NAME:     GTD_Capture
   :END:
   Rather than delegating on capture, I'll categorize tasks and notes
   on review.
   #+BEGIN_SRC emacs-lisp
     (setq org-capture-templates
	    `(("i" "Inbox" entry  (file "inbox.org")
	     ,(concat "* TODO %(sdate) - %?"))))

     (defun org-capture-inbox ()
       (interactive)
       (call-interactively 'org-store-link)
       (org-capture nil "i"))

     (global-set-key (kbd "C-c a") 'org-agenda)
     (global-set-key (kbd "C-c c") 'org-capture-inbox)
   #+END_SRC
*** TODO Once using mu4e add captures
    #+BEGIN_SRC emacs-lisp
         ("@" "Inbox [mu4e]" entry (file "inbox.org")
         ,(concat "* TODO Process \"%a\" %?\n"
                  "/Entered on/ %U"))

         (defun org-capture-mail ()
           (interactive)
           (call-interactively 'org-store-link)
           (org-capture nil "@"))
         (define-key mu4e-headers-mode-map (kbd "C-c c") 'mu4e-org-store-and-capture)
         (define-key mu4e-view-mode-map    (kbd "C-c c") 'mu4e-org-store-and-capture)
    #+END_SRC
*** DISABLED Fullscreen Capture
    #+BEGIN_SRC emacs-lisp
    ;(add-hook 'org-capture-mode-hook 'delete-other-windows)
    #+END_SRC
**** TODO That was enabled even though it's marked as DISABLED
** Agenda
   |-----------+---------|
   | Action    | Keybind |
   |-----------+---------|
   | Mark Done | t       |
   |-----------+---------|
*** GTD Agenda Display
    #+BEGIN_SRC emacs-lisp
      (setq org-agenda-custom-commands
	    '(("g" "Get Things Done (GTD)"
	       ((agenda ""
			((org-agenda-skip-function
			  '(org-agenda-skip-entry-if 'deadline))
			 (org-deadline-warning-days 0)))
		(todo "TODO"
		      ((org-agenda-skip-function
			'(org-agenda-skip-entry-if 'deadline))
		       (org-agenda-prefix-format "  %i %-12:c [%e] ")
		       (org-agenda-overriding-header "\nTasks\n")))
		(agenda nil
			((org-agenda-entry-types '(:deadline))
			 (org-agenda-format-date "")
			 (org-deadline-warning-days 7)
			 (org-agenda-skip-function
			  '(org-agenda-skip-entry-if 'notregexp "\\* NEXT"))
			 (org-agenda-overriding-header "\nDeadlines")))
		(tags "CLOSED>=\"<today>\""
		      ((org-agenda-overriding-header "\nCompleted today\n")))))))
    #+END_SRC
**** TODO Don't list events with deadlines in regular TODO section
*** TODO Have Org-Agenda not close all other windows
*** Calendar
    #+BEGIN_SRC emacs-lisp
      (setq org-agenda-include-diary t)
    #+END_SRC
**** Personal Calendar View
     Show 9 days starting with yesterday; that is, yesterday and the
     coming week.
     #+BEGIN_SRC emacs-lisp
       (setq org-agenda-start-day "-1d")
       (setq org-agenda-span 9)
       (setq org-agenda-start-on-weekday nil)
     #+END_SRC
***** TODO This only seems to show 7 days
      This is showing 9 days in the gtd agenda view
**** TODO Clean out obvious tasks
     There's no need to show the daily repeating unscheduled tasks on
     everyday after the first.
**** DISABLED Fix Diary to Work Inside of Org Agenda
     :PROPERTIES:
     :NAME:     Diary_in_Agenda
     :END:
     I'm not sure why diary entries in agenda files don't work as
     indicated in the [[info:org#Calendar/Diary integration][info page]] (by my reading).  I'm instead using
     this to allow diary entries in agenda files, checking before each
     viewing.
     #+BEGIN_SRC emacs-lisp
       (defun read-lines (filePath)
	 "Return a list of lines of a file at filePath."
	 (with-temp-buffer
	   (insert-file-contents filePath)
	   (split-string (buffer-string) "\n" t)))

       (defun agenda-diary-entries ()
	 "List the lines from org-agenda-files that belong in
	     diary-files."
	 (let ((agenda-files
		(if (stringp org-agenda-files)
		    (read-lines org-agenda-files)
		  org-agenda-files)))
	   (seq-filter
	    (lambda (s) (string-match "^[%][%]" s))
	    (apply #'append
		   (mapcar 'read-lines agenda-files)))))

       (defun string-list-to-file (string-list filePath)
	 "Save a list of strings as the lines in filePath."
	 (with-temp-file filePath
	   (mapcar (lambda (s) (insert s "\n")) string-list)))

       (defun update-diary-from-agenda ()
	 "Update (overwrite) the diary-file with lines from
       org-agenda-files."
	 (string-list-to-file (agenda-diary-entries) diary-file))

       ;(add-hook 'diary-hook #'update-diary-from-agenda)
     #+END_SRC
***** Disabled because the normal mode started working
**** TODO Google Calendar Things
** Time Tracking
   |-----------+-----------+------------|
   | Action    | Keybind   | Location   |
   |-----------+-----------+------------|
   | Clock in  | C-c C-x i | Org Header |
   | Clock Out | C-c C-x o | Org Header |
   |-----------+-----------+------------|
*** Track When Tasks are Completed
    #+BEGIN_SRC emacs-lisp
      (setq org-log-done 'time)
    #+END_SRC
*** TODO Star a timer when opening a file via a org link
    The idea version of this would be the project listing the folder
    it owns and all time spent with that folder as directory of the
    active frame is tracked.
*** TODO C-c C-x e sets time estate
    - Find a way to insert this into task creation
    - Find a way to collect data to verify this
    - Find a way to sort tasks by this (at least a little)
      - Probably also have an importance metric
      - This also falls into the dependency tracking and schedule solver
*** Track when activity becomes doable
    #+BEGIN_SRC emacs-lisp
      (defun log-todo-next-creation-date (&rest ignore)
	"Log NEXT creation time in the property drawer under the key 'ACTIVATED'"
	(when (and (string= (org-get-todo-state) "NEXT")
		   (not (org-entry-get nil "ACTIVATED")))
	  (org-entry-put nil "ACTIVATED" (format-time-string "[%Y-%m-%d]"))))
      (add-hook 'org-after-todo-state-change-hook #'log-todo-next-creation-date)
    #+END_SRC
**** TODO Have that track the NEXT to TODO change instead?
* Emacs Core Settings
** Setup Packages
*** Package Installation Settings
    :PROPERTIES:
    :NAME:     Initialize_Repos
    :END:
    #+BEGIN_SRC emacs-lisp
      (require 'package)
      (setq package-archives '(("gnu" . "https://elpa.gnu.org/packages/")
                               ("melpa" . "https://melpa.org/packages/") ; milkyPostman's rep
                               ("org" . "https://orgmode.org/elpa/"))) ; Org-mode's repository
      (package-initialize)
      (when (not package-archive-contents)
        (package-refresh-contents))
      (defun udh-install-and-load (package)
        (ignore-errors
          (unless (package-installed-p package)
            (package-install package))
          (require package)))
      (setq load-prefer-newer t)
      (udh-install-and-load 'auto-compile)
      (auto-compile-on-load-mode)
      (udh-install-and-load 'package-utils)
      (package-utils-upgrade-all)
    #+END_SRC
*** Install and Load Required Packages
    :PROPERTIES:
    :NAME:     Install_and_Load_Packages
    :END:
    #+BEGIN_SRC emacs-lisp
      (setq udh-package-list '(;;General Interface
			       bind-key
			       calendar
			       centered-cursor-mode
			       dynamic-spaces
			       hideshow
			       hideshowvis
			       highlight
			       highlight-blocks
			       highlight-current-line
			       highlight-indentation
			       highlight-parentheses
			       linum-relative
			       multiple-cursors
			       persistent-scratch
			       pretty-mode
			       undo-tree
			       ;; TODO: tmux-pane
			       tramp
			       ;; TODO: visible-mark
			       whitespace
			       ;; C++
			       ctags
			       ctags-update
			       flycheck
			       flymake
			       cppcheck
			       flymake-cppcheck
			       flymake-cursor
			       flymake-easy
			       smart-tabs-mode
			       ;; Git
			       magit
			       magit-filenotify
			       magit-popup
			       magit-tramp
			       ;; Other Modes
			       arduino-mode
			       cider ;; clojure
			       tramp-term
			       markdown-mode
			       ;helm-config
			       ;vagrant
			       ;vagrant-tramp
			       ;; Org Mode - After other languages are installed
			       ;; TODO: Read though the existing org plugins.
			       org
			       org-dotemacs
			       org-plus-contrib
			       org-bullets
			       ;;org-trello
			       org-preview-html
			       ;; Org Bable
			       ob-spice
			       ob-async
			       ob-diagrams
			       ;; ob-tmux ;; TODO: What does this even do?
			       ))
      (mapcar 'udh-install-and-load udh-package-list)
    #+END_SRC
** Interface Defaults
   :PROPERTIES:
   :NAME:     Interface_defaults
   :END:
   #+BEGIN_SRC emacs-lisp
     (setq inhibit-startup-message t ; prevent tutorial
	   initial-major-mode 'org-mode
	   initial-scratch-message "-*- mode: org -*-
     scratch

     "
	   sentence-end-double-space t)
     (menu-bar-mode -1)
     (tool-bar-mode -1)
     (scroll-bar-mode -1)
     ;; TODO: Disable suspention on gui clients and in
     ;; tmux.
     (global-unset-key (kbd "C-z"))

     ;; TODO unset (kbd "C-[") from ESC
    ;(define-key key-translation-map
    ;  [?\C-\[] nil);[(control left_bracket)])
    ;(define-key key-translation-map
    ;  (kbd "C-[") nil);[(control left_bracket)])
    ;(define-key key-translation-map
    ;  [escape] [?\e])
    ;(define-key key-translation-map
    ;  [escape] nil)
    ;(define-key key-translation-map
    ;  [?\e] nil)
    ;(when (boundp 'local-function-key-map)
    ;  ;;(define-key local-function-key-map)
    ;  (defun remove-escape-from-local-function-key-map ()
    ;    (define-key local-function-key-map [?\e] nil)
    ;    (define-key local-function-key-map [escape] nil)
    ;    (define-key local-function-key-map [?\C-\[] nil)
    ;    (define-key local-function-key-map (kbd "C-[") nil))
    ;  (add-hook 'term-setup-hook 'remove-escape-from-local-function-key-map))
   #+END_SRC
** Ask-Before-Closing
   :PROPERTIES:
   :NAME:     Ask_Before_Close
   :END:
   #+BEGIN_SRC emacs-lisp
     (defun close-frame-if-no-server ()
       (if (server-running-p)
           (condition-case err
               (delete-frame)
             (error (if (< emacs-major-version 22)
                        (save-buffers-kill-terminal)
                      (save-buffers-kill-emacs))))
         (if (< emacs-major-version 22)
             (save-buffers-kill-terminal)
           (save-buffers-kill-emacs))))
     (defun ask-before-closing ()
       "Ask whether or not to close, and then close if y was pressed"
       (interactive)
       (if (y-or-n-p (format "Are you sure you want to exit Emacs? "))
           (close-frame-if-no-server)
         (message "Canceled exit")))
     (global-set-key (kbd "C-x C-c") 'ask-before-closing)
   #+END_SRC
** Persistent-Scratch
   :PROPERTIES:
   :NAME:     Persistent_Scratch
   :END:
   #+BEGIN_SRC emacs-lisp
     (persistent-scratch-setup-default)
   #+END_SRC
** Disable IDO
   :PROPERTIES:
   :NAME:     No_IDO
   :END:
   IDO mode seems like a goodish idea, but it currently badly
   interacts with most of the rest of Emacs and had inconvenient
   ergonomics.  I'm disabling it for a few years and then will check
   back on it.

   At first I tried, =(ido-mode nil)= but that breaks org mode.

   Using =(unload-feature 'ido)= provides helpful errors but doesn't
   prevent ido from loading.

   #+BEGIN_SRC emacs-lisp
     (customize-set-variable
	  'package-load-list (quote (all (ido nil))))
     (customize-save-variable
	  'package-load-list (quote (all (ido nil))))
   #+END_SRC
* Global Presentation Settings
  :PROPERTIES:
  :NAME:     Text_Presentation_Settings
  :END:
** Highlight Parentheses
    :PROPERTIES:
    :NAME:     Highlight_Parentheses
    :END:
    #+BEGIN_SRC emacs-lisp
      (show-paren-mode 1)
    #+END_SRC
** Cyan Mini-Buffer
    :PROPERTIES:
    :NAME:     Mini_Buffer_Cyan
    :END:
    I like cyan, make that the mini buffer text colour.
    #+BEGIN_SRC emacs-lisp
      (add-hook 'tty-setup-hook
                (lambda () (set-face-foreground 'minibuffer-prompt "cyan")))
    #+END_SRC
** Spell Check Everywhere
    :PROPERTIES:
    :NAME:     Fly_Spell_Everywhere
    :END:
    Spelling is hard, enable spell checking everywhere I can.
    #+BEGIN_SRC emacs-lisp
      (defun turn-on-flyspell-prog ()
	"Unconditionally turn on Flyspell-prog mode."
	(flyspell-prog-mode 1))
      (add-hook 'text-mode-hook #'turn-on-flyspell)
      (add-hook 'prog-mode-hook #'turn-on-flyspell-prog)
    #+END_SRC
*** TODO Some modes seem to be not handled, namely org and magit-commit
    Looking into the run hooks, it claims that text-mode-hook should
    be run, org might just be clearing the minor mode away.
** Undo Tree Everywhere
    :PROPERTIES:
    :NAME:     Undo_Tree_Everwhere
    :END:
    While I don't use this often, it's really annoying when it's not
    on and I do want it.
    #+BEGIN_SRC emacs-lisp
      (defun turn-on-undo-tree ()
	"Unconditionally turn on undo-tree-mode."
	(undo-tree-mode 1))
      (add-hook 'text-mode-hook 'turn-on-undo-tree)
      (add-hook 'prog-mode-hook 'turn-on-undo-tree)
    #+END_SRC
*** TODO Can I have that enable when called rather than always on?
    I don't expect that the efficiency implications of this will
    matter, but it's good to care.
** TODO Tabs and Spaces
   :PROPERTIES:
   :NAME:     Tabs_and_Spaces_Settings
   :END:
   Move most of this into appropriate major modes instead of
   overriding defaults.
   #+BEGIN_SRC emacs-lisp
     (global-smart-tab-mode 1)
     (setq-default tab-width 2)
     (setq tab-width 2)
     (make-variable-buffer-local 'tab-width)
     (setq-default indent-tabs-mode t)
     (setq indent-tabs-mode t)
     (make-variable-buffer-local 'indent-tabs-mode)
   #+END_SRC
** Relative Line Numbers
   :PROPERTIES:
   :NAME:     Relitive_Line_Numbers
   :END:
   #+BEGIN_SRC emacs-lisp
     (setq relative-line-numbers-motion-function 'forward-visible-line)
   #+END_SRC
* Global Keyboard Interface
** TODO Unset Keys
   :PROPERTIES:
   :NAME:     Disabled_Kebinds
   :END:
   Move all unset keys to here, rather than where they relate to.
   Since I don't use them, I won't know what section they are in if
   I'm looking for them.
** TODO Navigation With C-c C-c
   :PROPERTIES:
   :NAME:     Follow_Links
   :END:
   While not in org-mode, have =C-c C-c= follow links into either org or eww.
   #+BEGIN_SRC emacs-lisp
   #+END_SRC
** Frame Movement
   :PROPERTIES:
   :NAME:     Frame_Control_Keys
   :END:
   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-x O") 'previous-multiframe-window)
   #+END_SRC
*** TODO C-x O moves between windows
    That's obnoxious, only move between frames in active client.
** Cursor Movement
   :PROPERTIES:
   :NAME:     Cursor_Movment_Changes
   :END:
   I prefer =C-a= going to the logical begging of line rather than the
   technical beginning of line.
   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-a") 'back-to-indentation)
     (global-unset-key (kbd "M-m"))
   #+END_SRC
** Multiple Cursors
   :PROPERTIES:
   :NAME:     Multiple_Cursors
   :END:
   #+BEGIN_SRC emacs-lisp
     ;(global-set-key (kbd "C-S-l") 'mc/edit-lines)
     (bind-key* "C-d"   'mc/mark-next-like-this)
     ;(global-set-key (kbd "C-S-d") 'mc/mark-previous-like-this)
     ;(global-set-key (kbd "C-M-d") 'mc/mark-all-like-this)
   #+END_SRC
*** TODO =C-d= is overridden in some modes, fix that.
** TODO ED
   :PROPERTIES:
   :NAME:     ED_Keys
   :END:
   Replicate the features of ED that I really like.

   This should be made into a minor mode once it's larger.

   (require 'multiple-cursors-mode)

   When searching, highlight all lines that are matching, make sure
   they are visible.  Reduce context around lines until all are
   visable on screen.

   Really, just make a regex search that filters the visible lines.
   And a second function to revert the view.
* Computer Specific
** Kitchen Sink (Laptop)
   :PROPERTIES:
   :NAME:     Kitchen_Sink
   :END:
   #+BEGIN_SRC emacs-lisp
     (setq is-kitchensink (string= "kitchensink" (system-name)))
   #+END_SRC
*** GUIX
    :PROPERTIES:
    :NAME:     Kitchensink_Guix
    :END:
    #+BEGIN_SRC emacs-lisp
      (if is-kitchensink
 	  (progn
		(mapcar 'udh-install-and-load '(guix pretty-sha-path))
	  ))
    #+END_SRC
**** TODO Something doesn't work here
**** TODO Move installed packages from zsh to here
*** Start EXWM
    :PROPERTIES:
    :NAME:     Kitchensink_EXWM_Init
    :END:
    #+BEGIN_SRC emacs-lisp
      (if is-kitchensink
	  (progn
	    (setq mouse-autoselect-window t
		  focus-follows-mouse t)

	    (mapcar 'udh-install-and-load '(exwm exwm-mff))
	    (require 'exwm)
	    (require 'exwm-config)
	    (exwm-config-default)
	    ;; TODO: bind S-x to match d-menu
	    (require 'exwm-systemtray)
	    (exwm-systemtray-enable)
	    (setq exwm-manage-force-tiling t)
	    ))
    #+END_SRC
**** TODO Check that =mouse-autoselect-window= don't stop the mouse following the window, it justs add synchrony.
** Windmills (Tower)
*** TODO Decrease emacs default font size two points
* Major Mode Settings
** EXWM
   :PROPERTIES:
   :NAME:     EXWM_settings
   :END:
   EXWM isn't loaded here since it's only wanted on some systems.
*** TODO Only run this section if exwm is loaded
*** Key-binds
    :PROPERTIES:
    :NAME:     EXWM_Keybinds
    :END:
    #+BEGIN_SRC emacs-lisp
      (setq exwm-input-global-keys
	`(([?\s-r] . exwm-reset)
	  ([?\s-w] . exwm-workspace-switch)
	  ,@(mapcar (lambda (i)
		      `(,(kbd (format "s-%d" i)) .
			(lambda ()
			  (interactive)
			  (exwm-workspace-switch-create ,i))))
		    (number-sequence 0 9))))

      (define-key exwm-mode-map [?\C-q] 'exwm-input-send-next-key)

    #+END_SRC
**** TODO Frame Navigation Keys
     Bind s-<XF86Back> and s-<XF86Forward> to 'previous-buffer and
     'next-buffer respectively, or something similar to move between
     frames or workspaces.
**** TODO Rescue C-c
     I don't like bindings to C-c, not really sure why.  There are
     several bindings to C-c in EXWM, move them over to s- bindings.

     Some of the default bindings are:
     |-------------+-------------------------------+-------------------------------------------------------------------------------------|
     | C-c C-f     | exwm-layout-set-fullscreen    | Enter fullscreen mode                                                               |
     | C-c C-h     | exwm-floating-hide            | Hide a floating X window                                                            |
     | C-c C-k     | exwm-input-release-keyboard   | Switch to char-mode                                                                 |
     | C-c C-m     | exwm-workspace-move-window    | Move X window to another workspace                                                  |
     | C-c C-q     | exwm-input-send-next-key      | Send a single key to the X window;   can be prefixed with C-u to send multiple keys |
     | C-c C-t C-f | exwm-floating-toggle-floating | Toggle between tiling and floating mode                                             |
     | C-c C-t C-m | exwm-layout-toggle-mode-line  | Toggle mode-line                                                                    |
     |-------------+-------------------------------+-------------------------------------------------------------------------------------|

     Probably map though them and bind them to S-c by default.

     Unbind all C-c Commands.  (Not sure if this sends C-c to
     underlying frame or just blocks it entirely.
     #+BEGIN_SRC emacs-lisp
       (define-key exwm-mode-map (kbd "C-c") nil)
     #+END_SRC
**** UNUSED Program Specific Bindings
     I don't have any yet, but they'll follow this form if I do
     #+BEGIN_SRC emacs-lisp
     (add-hook 'exwm-manage-finish-hook
          (lambda ()
            (when (and exwm-class-name
                       (string= exwm-class-name "XTerm"))
              (exwm-input-set-local-simulation-keys '(([?\C-c ?\C-c] . ?\C-c))))))
     #+END_SRC
*** TODO Task Safety
    Unbind M-! or have some timeout command on it.  Since Emacs is
    single threaded starting a non-forked task though M-! will block
    Emacs and therefore EXWM.
*** UNUSED Multi Screen
    If (when) I use EXWM on a multi screen computer.
    #+BEGIN_SRC emacs-lisp
      (require 'exwm-randr)
      (setq exwm-randr-workspace-output-plist '(0 "VGA1"))
      (add-hook 'exwm-randr-screen-change-hook
		(lambda ()
		  (start-process-shell-command
		   "xrandr" nil "xrandr --output VGA1 --left-of LVDS1 --auto")))
      (exwm-randr-enable)
    #+END_SRC
**** UNUSED Dynamic Multiple Monitors
     For if the docking station gets a second monitor again.
     #+BEGIN_SRC emacs-lisp
       (defun exwm-change-screen-hook ()
	 (let ((xrandr-output-regexp "\n\\([^ ]+\\) connected ")
	       default-output)
	   (with-temp-buffer
	     (call-process "xrandr" nil t nil)
	     (goto-char (point-min))
	     (re-search-forward xrandr-output-regexp nil 'noerror)
	     (setq default-output (match-string 1))
	     (forward-line)
	     (if (not (re-search-forward xrandr-output-regexp nil 'noerror))
		 (call-process "xrandr" nil nil nil "--output" default-output "--auto")
	       (call-process
		"xrandr" nil nil nil
		"--output" (match-string 1) "--primary" "--auto"
		"--output" default-output "--off")
	       (setq exwm-randr-workspace-output-plist (list 0 (match-string 1)))))))
     #+END_SRC
*** TODO Tabs
    Find a nest-able tabbed interface to use.  Some options are:
    Nerdtab, frame-tabs, rings, tab-group, tabbar, or there might be a
    EXWM builtin.
** Org Mode
   :PROPERTIES:
   :NAME:     Org_Mode_Settings
   :END:
   #+BEGIN_SRC emacs-lisp
     (defun udh-disable-tabs ()
       (setq indent-tabs-mode nil))
     (add-hook 'org-mode-hook 'udh-disable-tabs)
     (defun org-collapse-element ()
	"Moves to parent element and then collapses it."
	(interactive)
	(org-up-element)
	(org-cycle))
     (defun udh-org-mode-keys ()
       (local-set-key (kbd "RET") 'org-return-indent)
       ;;(local-set-key (kbd "M-C-RET") 'org-return)
       (local-set-key (kbd "M-[") 'org-backward-element)
       (local-set-key (kbd "M-]") 'org-forward-element)
       (local-set-key (kbd "M-{") 'org-collapse-element)
       (local-set-key (kbd "M-}") 'org-down-element)
       )
     (add-hook 'org-mode-hook
	       'udh-org-mode-keys)
   #+END_SRC
*** DISABLED Org Trello
    :PROPERTIES:
    :NAME:     Org_Trello
    :END:
    This is currently disabled because =org-trello= erroneously marks
    =ido= as required.
    #+BEGIN_SRC emacs-lisp
      (add-to-list 'auto-mode-alist '("\\.trello$"  . org-mode))
      ;; TODO: Find a better way to detect this.
      (defun udh-org-trello-detect ()
	(let ((filename (buffer-file-name (current-buffer))))
	  (when (and filename (string= "trello" (file-name-extension filename)))
	    (org-trello-mode))))
      (add-hook 'org-mode-hook 'udh-org-trello-detect)
    #+END_SRC
*** Org Babel
    :PROPERTIES:
    :NAME:     Org_Babel
    :END:
    #+BEGIN_SRC emacs-lisp
      (org-babel-do-load-languages
        'org-babel-load-languages
        '((emacs-lisp . t)
	  (dot . t)
	  (octave . t)))
    #+END_SRC
**** TODO Org Babel Confirmation
     :PROPERTIES:
     :NAME:     Org_Babel_Octave_Confirmation
     :END:
     Have this ask once per language per file, as it's currently
     written it's a security hole.
     #+BEGIN_SRC emacs-lisp
       (require `ob-octave)
       (setq org-confirm-babel-evaluate nil)
     #+END_SRC
*** TODO use these settings as default
    #+BEGIN_SRC org
    #+STARTUP: content showstars indent inlineimages hideblocks
    #+END_SRC
*** TODO Move C-c C-t to C-c t to match Org-Agenda
    This is part of a more general philosophy I'm trying to enforce;
    that org-mode and it's agenda is part of the interface of Emacs
    rather than a separate thing inside of it.  That all things being
    done are being done in a project and so that perspective should be
    wrapping it.
** C Like Languages
    :PROPERTIES:
    :NAME:     C_Languages
    :END:
    #+BEGIN_SRC emacs-lisp
       (smart-tabs-insinuate 'c 'c++)

       (defun udh-c-mode-layout ()
	 ;;(glasses-mode 1)
	 (require 'flymake-cursor)
	 (setq-default c-basic-offset 2
		       ;;tab-width 2
		       ;;indent-tabs-mode t
		       )
	 (hs-minor-mode 1)
	 ;(hideshowvis-minor-mode 1)
	 ;(hideshowvis-symbols)
	 (linum-relative-mode 1)
	 (require 'centered-cursor-mode)
	 (centered-cursor-mode 1)
	 ;;(hl-line-mode 1)
	 ;;(highlight-blocks-mode 1)
	 ;;(highlight-current-line-minor-mode 1)
	 ;;(highline-mode 1)
	 (flycheck-mode 1)
	 (flyspell-prog-mode)
	 )
       (add-hook 'c-mode-common-hook
		 'udh-c-mode-layout)
      (defun udh-c-mode-keys ()
        (local-set-key (kbd "C-,") 'flycheck-next-error)
	(local-set-key (kbd "C-t") 'hs-toggle-hiding)
	(local-set-key (kbd "C-M-t") 'hs-hide-level)
	(local-set-key (kbd "M-{") 'hs-hide-block)
	(local-set-key (kbd "M-}") 'hs-show-block)
	(local-set-key (kbd "C-S-b") (lambda () (interactive)
				       ;;(flycheck-select-checker 'c/c++-cppcheck)
				       (flymake-mode -1) (flymake-mode 1)
				       (local-set-key (kbd "C-M-S-e") 'flymake-goto-next-error)
				       (local-set-key (kbd "C-M-S-r") 'flymake-goto-prev-error)
				       ))
	(local-set-key (kbd "C-M-S-b") (lambda () (interactive)
					 (flycheck-mode -1) (flymake-mode -1)
					 (local-unset-key (kbd "C-M-S-e")) (local-unset-key (kbd "C-M-S-r"))))
	(setq tags-revert-without-query 1)
	)
      (add-hook 'c-mode-common-hook 'udh-c-mode-keys)
    #+END_SRC
*** TODO Toggle Hiding opens a new tab in some terminal emulators
*** DISABLED C Visual Symbols
    :PROPERTIES:
    :NAME:     C_Visual_Symbols
    :END:
    #+BEGIN_SRC emacs-lisp
      (defun udh-c-mode-prettify ()
	 (pretty-mode 1)
	 (pretty-regexp "--" "↧");"↓"
	 (pretty-regexp "[+][+]" "↥");"↑"
	 (pretty-regexp " *> > >" "⋙")
	 (pretty-regexp "< < < *" "⋘")
	 (pretty-regexp " *> >" "≫")
	 (pretty-regexp "< < *" "≪")
	 (pretty-regexp "<<" "《");"⩽"
	 ;;(pretty-regexp "< < <" "⫹")
	 (pretty-regexp ">>" "》");"⩾"
	 ;;(pretty-regexp "> > >" "⫺")
	 (pretty-regexp ">=" "≥")
	 (pretty-regexp "<=" "≤")
	 (pretty-regexp "!=" "≠")
	 (pretty-regexp "==" "≡")
	 (pretty-regexp "!" "¬")
	 (pretty-regexp "||" "∥")
	 (pretty-regexp "false" "⊭");⊥ true ᚁ and false ᚆ?
	 (pretty-regexp "true" "⊨")
	 (pretty-regexp "bool" "⊢");"╠";"├";"¤"
	 (pretty-regexp "float" "ℝ")
	 (pretty-regexp "\bint\b" "ℤ")
	 (pretty-regexp "char" "¶")
	 (pretty-regexp "void" "Ø")
	 (pretty-regexp "//" "⑊")
	 ;;(pretty-regexp "const" "𝌸")
	 ;;(pretty-regexp "[/][/][*]" "∫∮" )
	 ;;(pretty-regexp "[*][/][/]" "∮∫" )
	 ;;(pretty-regexp "[*][/]" "∮" )
	 ;;(pretty-regexp "[/][*]" "∮" )
	 ;;(pretty-regexp "[/][/]" "∬" )
	 ;;(pretty-regexp "[.]unlock()" "")
	 ;;(pretty-regexp "[.]lock()" "")
	 (pretty-regexp "std::deque" "ℚ");ɋʠ
	 (pretty-regexp "std::function" "ℱ");∳ƒⁿ
	 (pretty-regexp "std::ostream" "水");⇴⌫⼮
	 (pretty-regexp "std::atomic" "⚛");⌬
	 (pretty-regexp "std::thread" "⎇");↛ ⇶
	 (pretty-regexp "std::mutex" "↹");Θ ҉ ҈ ⊙ ↺
	 (pretty-regexp "std::map" "↦");"≔"
	 (pretty-regexp "std::pair" "⑵");"②";"ʭ"
	 (pretty-regexp "std::make_pair" "mk⑵")
	 (pretty-regexp "std::vector" "→")
	 (pretty-regexp "std::cin" "⌨")
	 ;;(pretty-regexp "std::buffer" "𝌖")
	 (pretty-regexp "[.]second" "₂")
	 (pretty-regexp "[.]first" "₁")
	 (pretty-regexp "template" "◳")
	 (pretty-regexp "()" "≬")
	 (pretty-regexp "std" "§");"準"
	 (pretty-regexp "::" "∷");"⁞"
	 (pretty-regexp "symbol" "※")
	 (pretty-regexp "Symbol" "⁜")
	 (pretty-regexp "Stream" "川")
	 (pretty-regexp "Thread" "⇶")
	 (pretty-regexp "Array" "⇻")
	 (pretty-regexp "Tree" "ᛘ");𝌎
	 ;;(pretty-regexp "Key" "🔑")
	 (pretty-regexp "[*]" "∗")
	 (pretty-mode -1)
      )
      (add-hook 'c-mode-common-hook 'udh-c-mode-prettify)
      (add-hook 'c-mode-common-hook
          '(lambda () (local-set-key (kbd "C-M-S-p")
              '(lambda () (interactive) (udh-c-mode-prettify)))))
    #+END_SRC
*** CPP Settings
    :PROPERTIES:
    :NAME:     Cpp_Settings
    :END:
    #+BEGIN_SRC emacs-lisp
      (add-to-list 'auto-mode-alist '("\\.tpp\\'" . c++-mode))
      (add-to-list 'auto-mode-alist '("\\.ino\\'" . c++-mode))
      (defun udh-set-flycheck-cpp-language-standard
		  (setq flycheck-clang-language-standard "c++1z"))
      (add-hook 'c++-mode-hook 'udh-set-flycheck-cpp-language-standard)
    #+END_SRC
*** TODO etags
    :PROPERTIES:
    :NAME:     Locate_Etags
    :END:
    Fix this to be use =which= or something.
    #+BEGIN_SRC emacs-lisp
      (setq path-to-ctags "/usr/bin/ctags-emacs-24")
    #+END_SRC
** Markdown
   :PROPERTIES:
   :NAME:     Markdown
   :END:
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'auto-mode-alist '("\\.md\\'"      . markdown-mode))
   #+END_SRC
** TODO Lisp
   :PROPERTIES:
   :NAME:     lisp_mode_settings
   :END:
   #+BEGIN_SRC emacs-lisp
     ;;(require 'rainbow-blocks)
     ;;(add-hook 'tty-setup-hook
     ;;    (add-hook 'lisp-mode-hook
     ;;              'rainbow-blocks-mode)
     (setq indent-tabs-mode nil)
   #+END_SRC
** TODO Python
   :PROPERTIES:
   :NAME:     Python
   :END:
   ;;;for python
   ;;enable elpy
   ;(elpy-enable)
   ;; set compleat to C-c k
   ;(define-key yas-minor-mode-map (kbd "C-c k") 'yas-expand)
   ;; set iedit mode
   ;(define-key global-map (kbd "C-c o") 'iedit-mode)
** IRC (ERC)
   :PROPERTIES:
   :NAME:     IRC
   :END:
   #+BEGIN_SRC emacs-lisp
     (add-hook 'erc-mode-hook
               (lambda ()
                 (flyspell-mode 1)
                 ))
     (add-hook 'erc-disconnected-hook
               (lambda (nick host-name reason)
                 ;; Re-establish the connection even if the server closed it.
                 (setq erc-server-error-occurred nil)))
     (setq erc-lurker-hide-list '("JOIN" "PART" "QUIT","MODE"))
     (setq erc-lurker-threshold-time 3600)
                                             ;(setq erc-hide-list '("JOIN" "PART" "QUIT" "MODE"))
                                             ;(setq erc-hide-list '())
     (setq erc-log-channels-directory "~/.erc/logs/")
     (add-hook 'erc-insert-post-hook 'erc-save-buffer-in-logs)
                                             ;that might make erc slow
                                             ;the forums are unsure
                                             ;https://www.emacswiki.org/emacs/ErcLogging#toc6
    #+END_SRC
** TODO EWW
   :PROPERTIES:
   :NAME:     EWW
   :END:
   Have each tab rename to the active site
   Have calling M-x eww make a new tab from any buffer
   Make a bookmark org file
   Have a "bookmark and close" function
   Have a "Dump all tabs to bookmarks" function
** Pascal
   :PROPERTIES:
   :NAME:     Pascal
   :END:
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'auto-mode-alist '("\\.simba\\'" . pascal-mode))
   #+END_SRC
* Minor Mode Settings
** Whitespace-Mode
   :PROPERTIES:
   :NAME:     Whitespace_Mode
   :END:
   #+BEGIN_SRC emacs-lisp
     (add-hook 'whitespace-load-hook
	       '(lambda () (if (display-graphic-p)
			       (progn (whitespace-mode 1)
				      (setq whitespace-style
					    '(face tabs spaces trailing space-before-tab
						   newline indentation empty space-after-tab
						   space-mark tab-mark newline-mark)))
			     (progn (whitespace-mode 1)
				    (setq whitespace-style
					  '(face tabs trailing space-before-tab
						 newline indentation empty
						 space-mark tab-mark newline-mark))))))
     (setq whitespace-empty-at-eob-regexp "^
     \\([

     ]+\\)");set it not to care about the first empty line (org files tend to have one)
   #+END_SRC
*** TODO Organize that code better and give the function a name
** TRAMP
   :PROPERTIES:
   :NAME:     Tramp
   :END:
   #+BEGIN_SRC emacs-lisp
     (setq tramp-default-method "ssh")
   #+END_SRC
** TODO Flymake
   Move flymake errors to mini-buffer.
* Unsorted TODOs
** TODO YASnippet
   #+BEGIN_SRC emacs-lisp
                                             ;(yas-reload-all)
                                             ;(setq yas-snippet-dirs '("~/emacs.d/snippets"))
                                             ;(setq yas/root-directory '"~/.emacs.d/snippets")
                                             ;(yas/reload-all)
   #+END_SRC
** TODO Helm
   (helm-mode 1)
** correct M-arrow to move paragraphs rather than single lines
   (defun org-transpose-paragraphs (arg)
   (interactive)
   (when (and (not (or (org-at-table-p) (org-on-heading-p) (org-at-item-p)))
   (thing-at-point 'sentence))
   (transpose-paragraphs arg)
   (backward-paragraph)
   (re-search-forward "[[:graph:]]")
   (goto-char (match-beginning 0))
   t))
   (add-to-list 'org-metaup-hook
   (lambda () (interactive) (org-transpose-paragraphs -1)))
   (add-to-list 'org-metadown-hook
   (lambda () (interactive) (org-transpose-paragraphs 1)))
** magit change logs use current org heading as function for description
   (defun org-log-current-defun ()
   (save-excursion
   (org-back-to-heading)
   (if (looking-at org-complex-heading-regexp)
   (match-string 4))))
   (add-hook 'org-mode-hook
   (lambda ()
   (make-variable-buffer-local 'add-log-current-defun-function)
   (setq add-log-current-defun-function 'org-log-current-defun)))
** org-export latex settings
   (add-to-list 'org-latex-classes
   '("udh-books"
   "\\documentclass{book}
   \\usepackage{braket}"
   ("\\part{%s}" . "\\part*{%s}")
   ("\\chapter{%s}" . "\\chapter*{%s}")
   ("\\section{%s}" . "\\section*{%s}")
   ("\\subsection{%s}" . "\\subsection*{%s}")
   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))

   (add-to-list 'org-latex-classes
   '("udh-article"
   "\\documentclass{scrartcl}
   \\usepackage{braket}"
   ("\\section{%s}" . "\\section*{%s}")
   ("\\subsection{%s}" . "\\subsection*{%s}")
   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
   ("\\paragraph{%s}" . "\\paragraph*{%s}")
   ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

   (add-to-list 'org-latex-classes
   '("udh-pub"
   "\\documentclass{book}
   \\usepackage{braket}"
   ("\\chapter{%s}" . "\\chapter*{%s}")
   ("\\section{%s}" . "\\section*{%s}")
   ("\\subsection{%s}" . "\\subsection*{%s}")
   ;("\\subsubsection{%s}" . "\\subsubsection*{%s}")
   ;("\\paragraph{%s}" . "\\paragraph*{%s}")
   ;("\\subparagraph{%s}" . "\\subparagraph*{%s}")
   ))

   ; Forward/Preface
   ; Table of Contents
   ; Introduction
   ; Chapter 1
   ; ...
